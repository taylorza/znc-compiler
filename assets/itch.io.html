<h2 id="znc---a-native-compiler-for-the-zx-spectrum-next">ZNC - A native compiler for the ZX Spectrum Next</h2>
<p>ZNC is a language and compiler for the ZX Spectrum Next. The language is closely modeled after the C programming language, but does deviate in some cases where it either made the language easier to parse or in other cases where I preferred an alternate syntax.</p>
<p>The compiler is a non-optimizing single pass compiler, while the generated code is not the fastest or the smallest it should outperform non-compiled languages.</p>
<p>In this language:</p>
<p><strong>Build Directives.</strong> A program may start with optional build directives:</p>
<ul>
<li>The <code>make</code> directive configures the build mode (with options &quot;dot&quot;, &quot;nex&quot;, or &quot;raw&quot;) and optionally a string specifying the name an location of the resulting binary.</li>
<li>The org directive sets the origin (memory address) of the code.</li>
</ul>
<p><strong>Top‐Level Items.</strong> Programs are a sequence of top‑level items (declarations and/or statements). Unlike traditional C, top‑level statements are allowed. However, if a top‑level statement calls a function, the function must have been declared before its use—either via a full definition or via a prototype.</p>
<p><strong>Declarations.</strong> There are variable declarations, function definitions, and function prototypes. Variable types include scalar types (<code>char</code>, <code>byte</code>, <code>int</code>), arrays (e.g. <code>int[10]</code>), and pointers (e.g. <code>int*</code>).</p>
<p><strong>Control Structures.</strong> You’ll find the usual control constructs: <code>if</code>–<code>else</code>, <code>while</code>, and <code>for</code> loops, as well as statements such as <code>break</code>, <code>continue</code>, and <code>return</code>.</p>
<p><strong>Inline Assembly.</strong> A special <strong>asm</strong> block can be used to embed raw Z80N assembly code inside functions.</p>
<p><strong>I/O Primitives.</strong> For basic output, built‑in functions <code>putc()</code> and <code>puts()</code> are provided.</p>
<p><strong>Banks.</strong> A bank construct allows you to group a statement block into a memory bank</p>
<h2 id="installing-the-tools">Installing the tools</h2>
<p>The compiler includes a suite of tools:</p>
<ul>
<li><a href="https://github.com/taylorza/zed">ZED - A text editor</a></li>
<li><a href="https://github.com/taylorza/znc-compiler">ZNC - The compiler</a></li>
<li><a href="https://github.com/taylorza/zopt">ZOPT - A peephole optimizer</a></li>
<li><a href="https://taylorza.itch.io/nextbasic-inline-assembler">ASM - Assembler</a></li>
<li><a href="https://github.com/taylorza/znc-compiler">ZIDE - Front-end driver</a></li>
</ul>
<p><a href="https://taylorza.itch.io/znc-compiler"><strong>Download: ZNC COMPILER</strong></a></p>
<p>Start by copying the downloaded zip file to the root directory of your NextZXOS SD Card. Then, from the NextZXOS command line, enter:</p>
<pre><code>.unzip -o znc.zip
</code></pre>
<p>Once the extraction is complete, four binary components will be installed as DOT commands, and a new ZDEV directory will appear in the root. Navigate to this directory, where you will find a collection of sample programs.</p>
<p>To see how the samples are compiled, optimized, and assembled, open <code>zncdemo.bas</code> and run it. A menu will be displayed, allowing you to select a sample to execute. As each step unfolds on the screen, you will get a clear understanding of the process involved in compiling your own applications.</p>
<h2 id="compiling-code">Compiling code</h2>
<p>Compilation is a two stage process.</p>
<ol>
<li>Compile the source code to assembly language</li>
</ol>
<p>The following will compile a source file called demo.znc to a corresponding assembly file called demo.asm.</p>
<pre><code>.znc demo.znc
</code></pre>
<ol>
<li>Assemble the file to the executable binary</li>
</ol>
<p>Using the NextBASIC Inline Assembler, you assemble the generated assembly file to a binary.</p>
<pre><code>.asm demo.asm
</code></pre>
<p>Now you should have file called <code>demo</code> in the DOT directory on your SD Card. This DOT command can be tested by executing the following at the command line.</p>
<pre><code>.demo
</code></pre>
<h2 id="examples">Examples</h2>
<h3 id="hello-world">Hello world</h3>
<p>Create a file called <code>hello.znc</code> and add the following content</p>
<pre><code>make dot &quot;/dot/hello&quot;;

puts(&quot;Hello World&quot;);
</code></pre>
<p>Next, compile and assemble the code</p>
<pre><code>.znc hello.znc
.asm hello.asm
</code></pre>
<p>If you did not get any errors with the above, you can excute the program and you should see <code>Hello World</code> printed to the screen.</p>
<h3 id="bouncing-ball">Bouncing ball</h3>
<p>This is a more complex example that bounces a character on the screen.</p>
<pre><code class="language-C">make dot &quot;/dot/ball&quot;;

void gotoxy(byte x, byte y) {
  putc(22);putc(y);putc(x);
}

int x=15, y=10;
int dx=1, dy=1;
byte n = 0;

while (1) {
  __asm__ {
    halt
    ld a, (_n)
    out ($fe), a
  }
  
  gotoxy(x, y);
  putc(&#39; &#39;);
  x = x + dx;
  y = y + dy;
  if (x == 0 || x == 31) { dx = -dx; n=(n+1) &amp; 7; }
  if (y == 0 || y == 21) { dy = -dy; n=(n+1) &amp; 7; }
  gotoxy(x, y);
  putc(&#39;*&#39;);
}
</code></pre>
<h2 id="syntax-incomplete">Syntax</h2>
<pre><code class="language-EBNF">(* Program directives and top‐level items, where declarations and statements may appear. *)
<program>         ::= [ <make> ]
                      [ <org> ]
                      { <top_level_item> }

<top_level_item>  ::= <decl>
                      | <statement>

<make>            ::= "make" [ "dot" | "nex" | "raw" ] "(" <string> ")" ";"

<org>             ::= "org" <number> ";"

<bank>            ::= "bank" "(" <number> [ "," <number> ] ")" <stmnt_block>

(* Statements *)
<statement>       ::= <stmnt_block>
                      | <decl>
                      | <assignment>                    
                      | <if>
                      | <switch>
                      | <while>
                      | <for>
                      | <break>
                      | <continue>
                      | <return>
                      | <putc>
                      | <puts>
                      | <asm>
                      | <include>
                      | <expr>
                      | <org>
                      | ";"

<stmnt_block>     ::= "{" { <statement> } "}"

(* Declarations: variable declarations, function definitions, and function prototypes *)
<decl>            ::= <vardecl>
                      | <funcdecl>
                      | <funcproto>

(* Function prototype: note the trailing semicolon instead of a body *)
<funcproto>       ::= <rettype> <ident> "(" <arglist> ")" ";"

(* Assignment expressions. Either a simple identifier or a more complex lvalue/expression on the left-hand side. *)
<assignment>      ::= <lvalue> "=" <expr> ";"
<lvalue>          ::= <ident>
                    | <ident> "[" <expr> "]"
                    | "*" <lvalue>
                    | "&" <lvalue>

(* Control structures *)
<if>              ::= "if" "(" <expr> ")" <statement> [ "else" <statement> ]

<switch>          ::= "switch" "(" <expr> ")" <switch_block>
<switch_block>    ::= "{" { <case_section> } "}"
<case_section>    ::= <case_header> { <statement> }
<case_header>     ::= { "case" <expr> ":" } [ "default" ":" ]

<while>           ::= "while" "(" <expr> ")" <statement>

<for>             ::= "for" "(" [ <decl> | <assignment> ] ";" [ <expr> ] ";" [ <expr> ] ")" <statement>

<break>           ::= "break" ";"

<continue>        ::= "continue" ";"

<return>          ::= "return" [ <expr> ] ";"

<putc>            ::= "putc" "(" <expr> ")" ";"

<puts>            ::= "puts" "(" <expr> ")" ";"

(* Inline assembly block (contents treated as raw Z80N Assembly). *)
<asm>             ::= "__asm__" "{" Z80N_Assembly "}"

<include>         ::= "include" <string>

(* String literal: content details omitted here *)
<string>          ::= "\"" { <character> } "\""

(* Variable declaration: type, identifier, and optional initializer.
   Multiple variables may be declared in one statement. *)
<vardecl>         ::= [const] <type> <ident> [ "=" <expr> ] { "," <ident> [ "=" <expr> ] } ";"

(* Function definition: includes return type, name, parameter list,
   either an assembly block, or a function body. *)
<funcdecl>        ::= <rettype> <ident> "(" <arglist> ")"  <asm> | <stmnt_block>

(* Function call used as an expression; when used as a statement, a semicolon is appended. *)
<call_expr>       ::= <ident> "(" [ <exprlist> ] ")"
<funccall_stmt>   ::= <call_expr> ";"

<rettype>         ::= "void" | <type>

(* Type definitions include scalar types, arrays, and pointers. *)
<type>            ::= <scalartype>
                      | <arraytype>
                      | <pointertype>

<scalartype>      ::= "char" | "byte" | "int"

<arraytype>       ::= <scalartype> "[" <number> "]"

<pointertype>     ::= <scalartype> "*"

<arglist>         ::= <arg> { "," <arg> }

<arg>             ::= <type> <ident>

(* Expressions are parsed using a precedence-climbing algorithm.
   The production below is schematic. *)
<expr>            ::= "(" <expr> ")" 
                      | <factor> { <op> <factor> }

<factor>          ::= <number>
                      | <string>
                      | <call_expr>
                      | ( "*" | "&" ) <var> [ "[" <expr> "]" ]

<var>             ::= <ident>

(* Operators available (similar to C, but with ++/-- excluded) *)
<op>              ::= "+" | "-" | "*" | "/" | "%" 
                      | "==" | "!=" | "<" | ">" | "<=" | ">=" 
                      | "&&" | "||" | "^" | "|" | "&" | "<<" | ">>"

(* Identifiers, letters, and digits *)
<ident>           ::= <letter> { <letter> | <digit> | "_" }

<letter>          ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
                      | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
                      | "U" | "V" | "W" | "X" | "Y" | "Z"
                      | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j"
                      | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t"
                      | "u" | "v" | "w" | "x" | "y" | "z"

<digit>           ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<number>          ::= <digit> { <digit> }

<character>       ::= /* any character except the double quote " */  
                     

(* The nonterminal Z80N_Assembly is assumed to represent a block of valid Z80N assembly code. *)
               
</code></pre>
