<h2 id="znc---a-native-compiler-for-the-zx-spectrum-next">ZNC - A native compiler for the ZX Spectrum Next</h2>
<p>ZNC is a language and compiler for the ZX Spectrum Next. The language is closely modeled after the C programming language, but does deviate in some cases where it either made the language easier to parse or in other cases where I preferred an alternate syntax.</p>
<p>The compiler is a non-optimizing single pass compiler, while the generated code is not the fastest or the smallest it should outperform non-compiled languages.</p>
<p>In this language:</p>
<p><strong>Build Directives.</strong> A program may start with optional build directives:</p>
<ul>
<li>The <code>make</code> directive configures the build mode (with options &quot;dot&quot;, &quot;nex&quot;, or &quot;raw&quot;) and optionally a string specifying the name an location of the resulting binary.</li>
<li>The org directive sets the origin (memory address) of the code.</li>
</ul>
<p><strong>Top‐Level Items.</strong> Programs are a sequence of top‑level items (declarations and/or statements). Unlike traditional C, top‑level statements are allowed. However, if a top‑level statement calls a function, the function must have been declared before its use—either via a full definition or via a prototype.</p>
<p><strong>Declarations.</strong> There are variable declarations, function definitions, and function prototypes. Variable types include scalar types (<code>char</code>, <code>byte</code>, <code>int</code>), arrays (e.g. <code>int[10]</code>), and pointers (e.g. <code>int*</code>).</p>
<p><strong>Control Structures.</strong> You’ll find the usual control constructs: <code>if</code>–<code>else</code>, <code>while</code>, and <code>for</code> loops, as well as statements such as <code>break</code>, <code>continue</code>, and <code>return</code>.</p>
<p><strong>Inline Assembly.</strong> A special <strong>asm</strong> block can be used to embed raw Z80N assembly code inside functions.</p>
<p><strong>I/O Primitives.</strong> For basic output, built‑in functions <code>putc()</code> and <code>puts()</code> are provided.</p>
<p><strong>Banks.</strong> A bank construct allows you to group a statement block into a memory bank</p>
<h2 id="installing-the-tools">Installing the tools</h2>
<p>The compiler includes a suite of tools:</p>
<ul>
<li><a href="https://github.com/taylorza/zed">ZED - A text editor</a></li>
<li><a href="https://github.com/taylorza/znc-compiler">ZNC - The compiler</a></li>
<li><a href="https://github.com/taylorza/zopt">ZOPT - A peephole optimizer</a></li>
<li><a href="https://taylorza.itch.io/nextbasic-inline-assembler">ASM - Assembler</a></li>
<li><a href="https://github.com/taylorza/znc-compiler">ZIDE - Front-end driver</a></li>
</ul>
<p><a href="https://taylorza.itch.io/znc-compiler"><strong>Download: ZNC COMPILER</strong></a></p>
<p>Start by copying the downloaded zip file to the root directory of your NextZXOS SD Card. Then, from the NextZXOS command line, enter:</p>
<pre><code>.unzip -o znc.zip
</code></pre>
<p>Once the extraction is complete, four binary components will be installed as DOT commands, and a new ZDEV directory will appear in the root. Navigate to this directory, where you will find a collection of sample programs.</p>
<p>To see how the samples are compiled, optimized, and assembled, open <code>zncdemo.bas</code> and run it. A menu will be displayed, allowing you to select a sample to execute. As each step unfolds on the screen, you will get a clear understanding of the process involved in compiling your own applications.</p>
<h2 id="compiling-code">Compiling code</h2>
<p>Compilation is a two stage process.</p>
<ol>
<li>Compile the source code to assembly language</li>
</ol>
<p>The following will compile a source file called demo.znc to a corresponding assembly file called demo.asm.</p>
<pre><code>.znc demo.znc
</code></pre>
<ol>
<li>Assemble the file to the executable binary</li>
</ol>
<p>Using the NextBASIC Inline Assembler, you assemble the generated assembly file to a binary.</p>
<pre><code>.asm demo.asm
</code></pre>
<p>Now you should have file called <code>demo</code> in the DOT directory on your SD Card. This DOT command can be tested by executing the following at the command line.</p>
<pre><code>.demo
</code></pre>
<h2 id="examples">Examples</h2>
<h3 id="hello-world">Hello world</h3>
<p>Create a file called <code>hello.znc</code> and add the following content</p>
<pre><code>make dot &quot;/dot/hello&quot;;

puts(&quot;Hello World&quot;);
</code></pre>
<p>Next, compile and assemble the code</p>
<pre><code>.znc hello.znc
.asm hello.asm
</code></pre>
<p>If you did not get any errors with the above, you can excute the program and you should see <code>Hello World</code> printed to the screen.</p>
<h3 id="bouncing-ball">Bouncing ball</h3>
<p>This is a more complex example that bounces a character on the screen.</p>
<pre><code class="language-C">make dot &quot;/dot/ball&quot;;

void gotoxy(byte x, byte y) {
  putc(22);putc(y);putc(x);
}

int x=15, y=10;
int dx=1, dy=1;
byte n = 0;

while (1) {
  __asm__ {
    halt
    ld a, (_n)
    out ($fe), a
  }
  
  gotoxy(x, y);
  putc(&#39; &#39;);
  x = x + dx;
  y = y + dy;
  if (x == 0 || x == 31) { dx = -dx; n=(n+1) &amp; 7; }
  if (y == 0 || y == 21) { dy = -dy; n=(n+1) &amp; 7; }
  gotoxy(x, y);
  putc(&#39;*&#39;);
}
</code></pre>
<h2 id="syntax-incomplete">Syntax</h2>
<pre><code class="language-EBNF">(* Program directives and top‐level items, where declarations and statements may appear. *)
&lt;program&gt;         ::= [ &lt;make&gt; ]
                      [ &lt;org&gt; ]
                      { &lt;top_level_item&gt; }

&lt;top_level_item&gt;  ::= &lt;decl&gt;
                      | &lt;statement&gt;

&lt;make&gt;            ::= "make" [ "dot" | "nex" | "raw" ] "(" &lt;string&gt; ")" ";"

&lt;org&gt;             ::= "org" &lt;number&gt; ";"

&lt;bank&gt;            ::= "bank" "(" &lt;number&gt; [ "," &lt;number&gt; ] ")" &lt;stmnt_block&gt;

(* Statements *)
&lt;statement&gt;       ::= &lt;stmnt_block&gt;
                      | &lt;decl&gt;
                      | &lt;assignment&gt;                    
                      | &lt;if&gt;
                      | &lt;switch&gt;
                      | &lt;while&gt;
                      | &lt;for&gt;
                      | &lt;break&gt;
                      | &lt;continue&gt;
                      | &lt;return&gt;
                      | &lt;putc&gt;
                      | &lt;puts&gt;
                      | &lt;asm&gt;
                      | &lt;include&gt;
                      | &lt;expr&gt;
                      | &lt;org&gt;
                      | ";"

&lt;stmnt_block&gt;     ::= "{" { &lt;statement&gt; } "}"

(* Declarations: variable declarations, function definitions, and function prototypes *)
&lt;decl&gt;            ::= &lt;vardecl&gt;
                      | &lt;funcdecl&gt;
                      | &lt;funcproto&gt;

(* Function prototype: note the trailing semicolon instead of a body *)
&lt;funcproto&gt;       ::= &lt;rettype&gt; &lt;ident&gt; "(" &lt;arglist&gt; ")" ";"

(* Assignment expressions. Either a simple identifier or a more complex lvalue/expression on the left-hand side. *)
&lt;assignment&gt;      ::= &lt;lvalue&gt; "=" &lt;expr&gt; ";"
&lt;lvalue&gt;          ::= &lt;ident&gt;
                    | &lt;ident&gt; "[" &lt;expr&gt; "]"
                    | "*" &lt;lvalue&gt;
                    | "&" &lt;lvalue&gt;

(* Control structures *)
&lt;if&gt;              ::= "if" "(" &lt;expr&gt; ")" &lt;statement&gt; [ "else" &lt;statement&gt; ]

&lt;switch&gt;          ::= "switch" "(" &lt;expr&gt; ")" &lt;switch_block&gt;
&lt;switch_block&gt;    ::= "{" { &lt;case_section&gt; } "}"
&lt;case_section&gt;    ::= &lt;case_header&gt; { &lt;statement&gt; }
&lt;case_header&gt;     ::= { "case" &lt;expr&gt; ":" } [ "default" ":" ]

&lt;while&gt;           ::= "while" "(" &lt;expr&gt; ")" &lt;statement&gt;

&lt;for&gt;             ::= "for" "(" [ &lt;decl&gt; | &lt;assignment&gt; ] ";" [ &lt;expr&gt; ] ";" [ &lt;expr&gt; ] ")" &lt;statement&gt;

&lt;break&gt;           ::= "break" ";"

&lt;continue&gt;        ::= "continue" ";"

&lt;return&gt;          ::= "return" [ &lt;expr&gt; ] ";"

&lt;putc&gt;            ::= "putc" "(" &lt;expr&gt; ")" ";"

&lt;puts&gt;            ::= "puts" "(" &lt;expr&gt; ")" ";"

(* Inline assembly block (contents treated as raw Z80N Assembly). *)
&lt;asm&gt;             ::= "__asm__" "{" Z80N_Assembly "}"

&lt;include&gt;         ::= "include" &lt;string&gt;

(* String literal: content details omitted here *)
&lt;string&gt;          ::= "\"" { &lt;character&gt; } "\""

(* Variable declaration: type, identifier, and optional initializer.
   Multiple variables may be declared in one statement. *)
&lt;vardecl&gt;         ::= [const] &lt;type&gt; &lt;ident&gt; [ "=" &lt;expr&gt; ] { "," &lt;ident&gt; [ "=" &lt;expr&gt; ] } ";"

(* Function definition: includes return type, name, parameter list,
   either an assembly block, or a function body. *)
&lt;funcdecl&gt;        ::= &lt;rettype&gt; &lt;ident&gt; "(" &lt;arglist&gt; ")"  &lt;asm&gt; | &lt;stmnt_block&gt;

(* Function call used as an expression; when used as a statement, a semicolon is appended. *)
&lt;call_expr&gt;       ::= &lt;ident&gt; "(" [ &lt;exprlist&gt; ] ")"
&lt;funccall_stmt&gt;   ::= &lt;call_expr&gt; ";"

&lt;rettype&gt;         ::= "void" | &lt;type&gt;

(* Type definitions include scalar types, arrays, and pointers. *)
&lt;type&gt;            ::= &lt;scalartype&gt;
                      | &lt;arraytype&gt;
                      | &lt;pointertype&gt;

&lt;scalartype&gt;      ::= "char" | "byte" | "int"

&lt;arraytype&gt;       ::= &lt;scalartype&gt; "[" &lt;number&gt; "]"

&lt;pointertype&gt;     ::= &lt;scalartype&gt; "*"

&lt;arglist&gt;         ::= &lt;arg&gt; { "," &lt;arg&gt; }

&lt;arg&gt;             ::= &lt;type&gt; &lt;ident&gt;

(* Expressions are parsed using a precedence-climbing algorithm.
   The production below is schematic. *)
&lt;expr&gt;            ::= "(" &lt;expr&gt; ")" 
                      | &lt;factor&gt; { &lt;op&gt; &lt;factor&gt; }

&lt;factor&gt;          ::= &lt;number&gt;
                      | &lt;string&gt;
                      | &lt;call_expr&gt;
                      | ( "*" | "&" ) &lt;var&gt; [ "[" &lt;expr&gt; "]" ]

&lt;var&gt;             ::= &lt;ident&gt;

(* Operators available (similar to C, ++/-- can be prefix or postfix) *)
&lt;op&gt;              ::= "+" | "-" | "*" | "/" | "%" 
                      | "==" | "!=" | "&lt;" | "&gt;" | "&lt;=" | "&gt;=" 
                      | "&&" | "||" | "^" | "|" | "&" | "&lt;&lt;" | "&gt;&gt;"
                      | "++" | "--"

(* Identifiers, letters, and digits *)
&lt;ident&gt;           ::= &lt;letter&gt; { &lt;letter&gt; | &lt;digit&gt; | "_" }

&lt;letter&gt;          ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
                      | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
                      | "U" | "V" | "W" | "X" | "Y" | "Z"
                      | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j"
                      | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t"
                      | "u" | "v" | "w" | "x" | "y" | "z"

&lt;digit&gt;           ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

&lt;number&gt;          ::= &lt;digit&gt; { &lt;digit&gt; }

&lt;character&gt;       ::= /* any character except the double quote " */  
                     

(* The nonterminal Z80N_Assembly is assumed to represent a block of valid Z80N assembly code. *)
               
</code></pre>
