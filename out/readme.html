
<h1 id="znc---a-native-compiler-for-the-zx-spectrum-next">ZNC - A native compiler for the ZX Spectrum Next</h1>
<p>ZNC is a language and compiler for the ZX Spectrum Next. The language is closely modeled after the C programming language, but does deviate in some cases where it either made the language easier to parse or in other cases where I preferred an alternate syntax.</p>
<p>The compiler is a non-optimizing single pass compiler, while the generated code is not the fastest or the smallest it should outperform non-compiled languages.</p>
<p>In this language:</p>
<p><strong>Build Directives.</strong> A program may start with optional build directives:</p>
<ul>
<li>The <code>make</code> directive configures the build mode (with options &quot;dot&quot;, &quot;nex&quot;, or &quot;raw&quot;) and optionally a string specifying the name an location of the resulting binary.</li>
<li>The org directive sets the origin (memory address) of the code.</li>
</ul>
<p><strong>Top‐Level Items.</strong> Programs are a sequence of top‑level items (declarations and/or statements). Unlike traditional C, top‑level statements are allowed. However, if a top‑level statement calls a function, the function must have been declared before its use—either via a full definition or via a prototype.</p>
<p><strong>Declarations.</strong> There are variable declarations, function definitions, and function prototypes. Variable types include scalar types (<code>char</code>, <code>byte</code>, <code>int</code>), arrays (e.g. <code>int[10]</code>), and pointers (e.g. <code>int*</code>).</p>
<p><strong>Control Structures.</strong> You’ll find the usual control constructs: <code>if</code>–<code>else</code>, <code>while</code>, and <code>for</code> loops, as well as statements such as <code>break</code>, <code>continue</code>, and <code>return</code>.</p>
<p><strong>Inline Assembly.</strong> A special <strong>asm</strong> block can be used to embed raw Z80N assembly code inside functions.</p>
<p><strong>I/O Primitives.</strong> For basic output, built‑in functions <code>putc()</code> and <code>puts()</code> are provided.</p>
<p><strong>Banks.</strong> A bank construct allows you to group a statement block into a memory bank</p>
<h2 id="installing-the-tools">Installing the tools</h2>
<p>The compiler includes a suite of tools:</p>
<ul>
<li><a href="https://github.com/taylorza/zed">ZED - A text editor</a></li>
<li><a href="https://github.com/taylorza/znc-compiler">ZNC - The compiler</a></li>
<li><a href="https://github.com/taylorza/zopt">ZOPT - A peephole optimizer</a></li>
<li><a href="https://taylorza.itch.io/nextbasic-inline-assembler">ASM - Assembler</a></li>
<li><a href="https://github.com/taylorza/znc-compiler">ZIDE - Front-end driver</a></li>
</ul>
<p><a href="https://taylorza.itch.io/znc-compiler"><strong>Download: ZNC COMPILER</strong></a></p>
<p>Start by copying the downloaded zip file to the root directory of your NextZXOS SD Card. Then, from the NextZXOS command line, enter:</p>
<pre><code>.unzip -o znc.zip
</code></pre>
<p>Once the extraction is complete, four binary components will be installed as DOT commands, and a new ZDEV directory will appear in the root. Navigate to this directory, where you will find a collection of sample programs.</p>
<p>To see how the samples are compiled, optimized, and assembled, open <code>zncdemo.bas</code> and run it. A menu will be displayed, allowing you to select a sample to execute. As each step unfolds on the screen, you will get a clear understanding of the process involved in compiling your own applications.</p>
<h2 id="compiling-code">Compiling code</h2>
<p>Compilation is a two stage process.</p>
<ol>
<li>Compile the source code to assembly language</li>
</ol>
<p>The following will compile a source file called demo.znc to a corresponding assembly file called demo.asm.</p>
<pre><code>.znc demo.znc
</code></pre>
<ol>
<li>Assemble the file to the executable binary</li>
</ol>
<p>Using the NextBASIC Inline Assembler, you assemble the generated assembly file to a binary.</p>
<pre><code>.asm demo.asm
</code></pre>
<p>Now you should have file called <code>demo</code> in the DOT directory on your SD Card. This DOT command can be tested by executing the following at the command line.</p>
<pre><code>.demo
</code></pre>
<h2 id="examples">Examples</h2>
<h3 id="hello-world">Hello world</h3>
<p>Create a file called <code>hello.znc</code> and add the following content</p>
<pre><code>make dot &quot;/dot/hello&quot;;

puts(&quot;Hello World&quot;);
</code></pre>
<p>Next, compile and assemble the code</p>
<pre><code>.znc hello.znc
.asm hello.asm
</code></pre>
<p>If you did not get any errors with the above, you can excute the program and you should see <code>Hello World</code> printed to the screen.</p>
<h3 id="bouncing-ball">Bouncing ball</h3>
<p>This is a more complex example that bounces a character on the screen.</p>
<pre><code class="language-C">make dot &quot;/dot/ball&quot;;

void gotoxy(byte x, byte y) {
  putc(22);putc(y);putc(x);
}

int x=15, y=10;
int dx=1, dy=1;
byte n = 0;

while (1) {
  __asm__ {
    halt
    ld a, (_n)
    out ($fe), a
  }
  
  gotoxy(x, y);
  putc(&#x27; &#x27;);
  x = x + dx;
  y = y + dy;
  if (x == 0 || x == 31) { dx = -dx; n=(n+1) &amp; 7; }
  if (y == 0 || y == 21) { dy = -dy; n=(n+1) &amp; 7; }
  gotoxy(x, y);
  putc(&#x27;*&#x27;);
}
</code></pre>
<h2 id="using-zide">Using ZIDE</h2>
<p>As an alternative to using the command line, you can use ZIDE which provides a more user friendly development environment.
ZIDE is a NextBASIC program that can be executed from the Browser or from the command line using the following commands.</p>
<pre><code>load &quot;zide.bas&quot;
run
</code></pre>
<p>Once the IDE is launched, you can use the highlighted hotkeys to set the various options and execute commands.</p>
<p><strong>Options:</strong></p>
<p><code>W</code> - Sets the working file, this is file that will be opened when you launch the editor with <code>E</code></p>
<p><code>M</code> - Sets the main file for your project. This is the root file that the compiler will start with</p>
<p><strong>Commands:</strong></p>
<p><code>E</code> - Edit the current working file</p>
<p><code>C</code> - Compile the main file, any files included by the main file will also be compiled</p>
<p><code>R</code> - Run the executable file. The first time you run, you will be prompted to select the executable file</p>
<p><code>N</code> - Start editing a new file</p>
<p><code>O</code> - Set compiler options</p>
<p><code>Q</code> - Exit the IDE</p>
<p><strong>Compiler Options</strong></p>
<p><code>O</code> from the main screen on the IDE brings you to the Compiler options screen. From this screen you can set the following options</p>
<p><code>O</code> - Toggle compiler optimization on/off. When off the resulting code is larger and slower, but compile times are much faster</p>
<p><code>C</code> - Set the command line arguments passed to your application when it is run from the main screen using the run command <code>R</code></p>
<p><code>B</code> - Takes you back to the previous screen in the IDE</p>
<p><strong>File Manager:</strong>
The file manager enables you to create shortcuts to files you use frequently, this can be handy in a multi file project.</p>
<p><code>F</code> - Takes you to the file manager where you can add/remove files from the slots provided.</p>
<p><code>0</code>..<code>9</code> - Opens the editor and loads the corresponding file for editing</p>
<p><code>B</code> - Takes you back to the previous screen in the IDE</p>
<h1 id="znc-language-reference">ZNC Language Reference</h1>
<p>The ZNC language is designed to offer a familiar C-like structure while seamlessly integrating inline Z80N assembly.</p>
<h2 id="basic-syntax">Basic Syntax</h2>
<p>A typical <code>ZNC</code> source file has two major parts, <strong>directives</strong> and <strong>code</strong></p>
<h3 id="directives">Directives</h3>
<p>Directives generally control the code generation process</p>
<h4 id="make">make</h4>
<p>An optional directive placed at the beginning of your source file. This directive configures the specific build options. For example, what type of binary to generate at assembly time and what the binary name should be.</p>
<p>If make is not specified, the compiled code will be assembled directly into memory. This can be useful if you want to compile ZNC code for use as inline code in your NextBASIC applications.</p>
<p><strong>Syntax</strong>
<code>make &lt;type&gt; [&quot;&lt;binary name&gt;&quot;];</code></p>
<p><code>&lt;type&gt;</code> - Specified the type of binary to create</p>
<ul>
<li>dot - Creates a DOT command binary</li>
<li>nex - Creates a NEX binary</li>
<li>raw - Raw creates a raw binary with the default code address set to 0xc000 hex or 49152 decimal</li>
</ul>
<p><code>[&quot;&lt;binary name&gt;&quot;]</code> - Optionally specifies the name of the resulting binary. If not provided, the source file name is used as the base of the binary name.</p>
<p><strong>Example:</strong>
Create a DOT command named hello in the DOT folder a the root of the current SD card.</p>
<p><code>make dot &quot;/dot/hello&quot;</code></p>
<h4 id="org">org</h4>
<p>This directive can occur anywhere in the code, but it is a rather advanced directive. It is used to control the base address used for code generation. If the code is compiled and assembled directly to memory ie. no <code>make</code> option was specified then it also controls the memory address the code will be assembled to.</p>
<p><strong>Syntax</strong>
<code>org &lt;address&gt;;</code></p>
<p><code>&lt;address&gt;</code> - Specifies the target address for the subsequent code</p>
<p><strong>Example:</strong>
Target code for address 0x8000</p>
<p><code>org 0x8000;</code></p>
<h4 id="bank">bank</h4>
<p>The <code>bank</code> directive is used to target code for specific banks. This is useful when compiling <code>NEX</code> or direct to memory binaries. Banks contain blocks of code and data.</p>
<p><strong>Syntax</strong>
<code>bank &lt;bankno&gt; '{' &lt;statements&gt; '}'</code></p>
<p><code>&lt;bankno&gt;</code> - The bank that the block of code will be compiled and assembled for.
<code>&lt;statements&gt;</code> - The code that will be included in this bank</p>
<p><strong>Example:</strong>
Compile code for bank 40</p>
<pre><code class="language-c">bank 40 {
  for(char ch=&#x27;A&#x27;; ch&lt;=&#x27;Z&#x27;; ch=ch+1) {
    putc(ch)
  }
}
</code></pre>
<h3 id="code">Code</h3>
<p>The main component of your application is the code, the instructions that the compiler will transform into executable code and data.</p>
<h2 id="data-types">Data types</h2>
<p>The ZNC compiler supports the following data types</p>
<p>char - Character data type
byte - Byte values in the range -128..127
int  - Integer values in the range -32768..32767</p>
<p>You can also create pointers to or arrays for each of the data types.</p>
<h3 id="pointers">Pointers</h3>
<p>Pointers enable to you access data in memory at the address pointed to by the pointer. And integer pointer provides access to a 2 byte integer value at the target address, while a byte pointer accesses a single byte at the address pointed to by the pointer.</p>
<p>The follow will declare a pointer that points to the ZX Spectrum ULA screen memory and writes a byte to the screen.</p>
<pre><code>byte *screen = 0x4000; // ZX Spectrum ULA Screen address (16384 in decimal)
*screen = 255;         // Write the value 255 to the memory address pointed to by &quot;screen&quot;
</code></pre>
<h4 id="pointer-arithmetic">Pointer arithmetic</h4>
<p><strong>TODO</strong></p>
<h3 id="arrays">Arrays</h3>
<p>You can also create arrays of the base data types. For example if you wanted to store ten integers you could declare an array of integers as follows</p>
<pre><code class="language-C">int[10] numbers;
</code></pre>
<h4 id="array-access-and-initialization">Array access and initialization</h4>
<p><strong>TODO</strong></p>
<h3 id="declaring-variables">Declaring variables</h3>
<p>Variables can be declared at any point in the code</p>
<h2 id="syntax-incomplete">Syntax (incomplete)</h2>
<pre><code class="language-EBNF">(* Program directives and top‐level items, where declarations and statements may appear. *)
&lt;program&gt;         ::= [ &lt;make&gt; ]
                      [ &lt;org&gt; ]
                      { &lt;top_level_item&gt; }

&lt;top_level_item&gt;  ::= &lt;decl&gt;
                      | &lt;statement&gt;

&lt;make&gt;            ::= &quot;make&quot; [ &quot;dot&quot; | &quot;nex&quot; | &quot;raw&quot; ] &quot;(&quot; &lt;string&gt; &quot;)&quot; &quot;;&quot;

&lt;org&gt;             ::= &quot;org&quot; &lt;number&gt; &quot;;&quot;

&lt;bank&gt;            ::= &quot;bank&quot; &quot;(&quot; &lt;number&gt; [ &quot;,&quot; &lt;number&gt; ] &quot;)&quot; &lt;stmnt_block&gt;

(* Statements *)
&lt;statement&gt;       ::= &lt;stmnt_block&gt;
                      | &lt;decl&gt;
                      | &lt;assignment&gt;                    
                      | &lt;if&gt;
                      | &lt;switch&gt;
                      | &lt;while&gt;
                      | &lt;for&gt;
                      | &lt;break&gt;
                      | &lt;continue&gt;
                      | &lt;return&gt;
                      | &lt;putc&gt;
                      | &lt;puts&gt;
                      | &lt;asm&gt;
                      | &lt;include&gt;
                      | &lt;expr&gt;
                      | &lt;org&gt;
                      | &quot;;&quot;

&lt;stmnt_block&gt;     ::= &quot;{&quot; { &lt;statement&gt; } &quot;}&quot;

(* Declarations: variable declarations, function definitions, and function prototypes *)
&lt;decl&gt;            ::= &lt;vardecl&gt;
                      | &lt;funcdecl&gt;
                      | &lt;funcproto&gt;

(* Function prototype: note the trailing semicolon instead of a body *)
&lt;funcproto&gt;       ::= &lt;rettype&gt; &lt;ident&gt; &quot;(&quot; &lt;arglist&gt; &quot;)&quot; &quot;;&quot;

(* Assignment expressions. Either a simple identifier or a more complex lvalue/expression on the left-hand side. *)
&lt;assignment&gt;      ::= &lt;lvalue&gt; &quot;=&quot; &lt;expr&gt; &quot;;&quot;
&lt;lvalue&gt;          ::= &lt;ident&gt;
                    | &lt;ident&gt; &quot;[&quot; &lt;expr&gt; &quot;]&quot;
                    | &quot;*&quot; &lt;lvalue&gt;
                    | &quot;&amp;&quot; &lt;lvalue&gt;

(* Control structures *)
&lt;if&gt;              ::= &quot;if&quot; &quot;(&quot; &lt;expr&gt; &quot;)&quot; &lt;statement&gt; [ &quot;else&quot; &lt;statement&gt; ]

&lt;switch&gt;          ::= &quot;switch&quot; &quot;(&quot; &lt;expr&gt; &quot;)&quot; &lt;switch_block&gt;
&lt;switch_block&gt;    ::= &quot;{&quot; { &lt;case_section&gt; } &quot;}&quot;
&lt;case_section&gt;    ::= &lt;case_header&gt; { &lt;statement&gt; }
&lt;case_header&gt;     ::= { &quot;case&quot; &lt;expr&gt; &quot;:&quot; } [ &quot;default&quot; &quot;:&quot; ]

&lt;while&gt;           ::= &quot;while&quot; &quot;(&quot; &lt;expr&gt; &quot;)&quot; &lt;statement&gt;

&lt;for&gt;             ::= &quot;for&quot; &quot;(&quot; [ &lt;decl&gt; | &lt;assignment&gt; ] &quot;;&quot; [ &lt;expr&gt; ] &quot;;&quot; [ &lt;expr&gt; ] &quot;)&quot; &lt;statement&gt;

&lt;break&gt;           ::= &quot;break&quot; &quot;;&quot;

&lt;continue&gt;        ::= &quot;continue&quot; &quot;;&quot;

&lt;return&gt;          ::= &quot;return&quot; [ &lt;expr&gt; ] &quot;;&quot;

&lt;putc&gt;            ::= &quot;putc&quot; &quot;(&quot; &lt;expr&gt; &quot;)&quot; &quot;;&quot;

&lt;puts&gt;            ::= &quot;puts&quot; &quot;(&quot; &lt;expr&gt; &quot;)&quot; &quot;;&quot;

(* Inline assembly block (contents treated as raw Z80N Assembly). *)
&lt;asm&gt;             ::= &quot;__asm__&quot; &quot;{&quot; Z80N_Assembly &quot;}&quot;

&lt;include&gt;         ::= &quot;include&quot; &lt;string&gt;

(* String literal: content details omitted here *)
&lt;string&gt;          ::= &quot;\&quot;&quot; { &lt;character&gt; } &quot;\&quot;&quot;

(* Variable declaration: type, identifier, and optional initializer.
   Multiple variables may be declared in one statement. *)
&lt;vardecl&gt;         ::= [const] &lt;type&gt; &lt;ident&gt; [ &quot;=&quot; &lt;expr&gt; ] { &quot;,&quot; &lt;ident&gt; [ &quot;=&quot; &lt;expr&gt; ] } &quot;;&quot;

(* Function definition: includes return type, name, parameter list,
   either an assembly block, or a function body. *)
&lt;funcdecl&gt;        ::= &lt;rettype&gt; &lt;ident&gt; &quot;(&quot; &lt;arglist&gt; &quot;)&quot;  &lt;asm&gt; | &lt;stmnt_block&gt;

(* Function call used as an expression; when used as a statement, a semicolon is appended. *)
&lt;call_expr&gt;       ::= &lt;ident&gt; &quot;(&quot; [ &lt;exprlist&gt; ] &quot;)&quot;
&lt;funccall_stmt&gt;   ::= &lt;call_expr&gt; &quot;;&quot;

&lt;rettype&gt;         ::= &quot;void&quot; | &lt;type&gt;

(* Type definitions include scalar types, arrays, and pointers. *)
&lt;type&gt;            ::= &lt;scalartype&gt;
                      | &lt;arraytype&gt;
                      | &lt;pointertype&gt;

&lt;scalartype&gt;      ::= &quot;char&quot; | &quot;byte&quot; | &quot;int&quot;

&lt;arraytype&gt;       ::= &lt;scalartype&gt; &quot;[&quot; &lt;number&gt; &quot;]&quot;

&lt;pointertype&gt;     ::= &lt;scalartype&gt; &quot;*&quot;

&lt;arglist&gt;         ::= &lt;arg&gt; { &quot;,&quot; &lt;arg&gt; }

&lt;arg&gt;             ::= &lt;type&gt; &lt;ident&gt;

(* Expressions are parsed using a precedence-climbing algorithm.
   The production below is schematic. *)
&lt;expr&gt;            ::= &quot;(&quot; &lt;expr&gt; &quot;)&quot; 
                      | &lt;factor&gt; { &lt;op&gt; &lt;factor&gt; }

&lt;factor&gt;          ::= &lt;number&gt;
                      | &lt;string&gt;
                      | &lt;call_expr&gt;
                      | ( &quot;*&quot; | &quot;&amp;&quot; ) &lt;var&gt; [ &quot;[&quot; &lt;expr&gt; &quot;]&quot; ]

&lt;var&gt;             ::= &lt;ident&gt;

(* Operators available (similar to C, ++/-- can be prefix or postfix) *)
&lt;op&gt;              ::= &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;%&quot; 
                      | &quot;==&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot; 
                      | &quot;&amp;&amp;&quot; | &quot;||&quot; | &quot;^&quot; | &quot;|&quot; | &quot;&amp;&quot; | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot;
                      | &quot;++&quot; | &quot;--&quot;

(* Identifiers, letters, and digits *)
&lt;ident&gt;           ::= &lt;letter&gt; { &lt;letter&gt; | &lt;digit&gt; | &quot;_&quot; }

&lt;letter&gt;          ::= &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; | &quot;G&quot; | &quot;H&quot; | &quot;I&quot; | &quot;J&quot;
                      | &quot;K&quot; | &quot;L&quot; | &quot;M&quot; | &quot;N&quot; | &quot;O&quot; | &quot;P&quot; | &quot;Q&quot; | &quot;R&quot; | &quot;S&quot; | &quot;T&quot;
                      | &quot;U&quot; | &quot;V&quot; | &quot;W&quot; | &quot;X&quot; | &quot;Y&quot; | &quot;Z&quot;
                      | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot; | &quot;j&quot;
                      | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot; | &quot;q&quot; | &quot;r&quot; | &quot;s&quot; | &quot;t&quot;
                      | &quot;u&quot; | &quot;v&quot; | &quot;w&quot; | &quot;x&quot; | &quot;y&quot; | &quot;z&quot;

&lt;digit&gt;           ::= &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;

&lt;number&gt;          ::= &lt;digit&gt; { &lt;digit&gt; }

&lt;character&gt;       ::= /* any character except the double quote &quot; */  
                     

(* The nonterminal Z80N_Assembly is assumed to represent a block of valid Z80N assembly code. *)
               
</code></pre>
